各位朋友大家好：首次见面 先自我介绍一下，我是晓磊哥，一名工作十年的后端程序员，目前就职于鹅厂。

_大家好，我是一名半路出家的野生程序员。可以叫我大路。目前在一家互联网医疗创业公司做全栈。_

我们做这件事的初衷是，之前很多书，都没有坚持看完。我认为技术书籍区别于其他书籍的点在于：读技术书籍的时候需要不断的思考，遇到问题又不能直接向作者请教，又没有相对集中的地方进行讨论。所以想以一种讨论的方式想和大家一起养成坚持读书的习惯。

_那么今天我们读的第一本书是什么呢？_

今天我们来聊聊《Redis设计与实现》这本书。提到Redis相信很多码农都很熟悉。Redis是一个key-value存储系统，和Memcache类似，它支持存储的value类型相对更多，包括string、list、set、zset和hash 以及订阅/发布等功能。但这本书并不是介绍怎么使用Redis的，而是对Redis的实现原理进行了介绍，力图展示其核心数据结构以及关键的算法思想，并让我们能够快速、有效的了解Redis的内部构造以及其运作机制。

作者在这里吹了个牛逼，**如果只是对Redis实现原理感兴趣，但是又不想深入研究Redis源代码，那么读这本书就够了。**

_真的是这样吗?_

关于这个观点其实我不是特别赞同，就拿我举例子，有很多地方光看书就不是很容易理解。

_好，废话不多说，直奔主题。redis能存储这么多的value类型, 那它内置了哪些基础的数据结构？_

这里redis封装了一些数据结构，如：SDS（简单动态字符串）， 链表 ，跳跃表，整数集合，对象等。
      

## 简单动态字符串 SDS 
```
struct sdshdr {
	char buf[]; // 字节数组，用于保存字符串 
	int len; //buf数组中已使用字节的数量,等于SDS所保存字符串的长度 len 的值是5， 表示这个SDS 保存了5个字节长的字符串
	int free; // buf数组中未使用字节的数量 - free 的值是0，表示这个SDS分配的空间都被用完了。	
}
```

_len + free 就等于buf的length吗?_

最后一个字节则保存了空字符'\0'。但是最后一个字节'\0'是不计入len的。

_感觉这个sds和C字符串的功能差不多都是存字符串的嘛。为毛要多此一举封装一个结构体呢?_

这是因为，如果想在C中获取一个字符串的长度，需要遍历，_O(n)_ 但sds获取字符串长度复杂度 _O(1)_ 。
而且，在修改字符串时 ，如果新字符串的长度小于已经申请内存的大小，不需要重新申请内存。这样会减少内存重新分配的次数，避免频繁申请内存。
 
_很讲究嘛。这么设计还有什么优点？_

sds定义了一系列API，对SDS的操作都是通过API来操作的。 比如buf由小变大，sds会自动判断buf大小是否足够，如果不够重新申请内存。这样会避免内存溢出。

_也就是说REdis帮我们做了很多管理内存的工作，那它具体是怎么分配和管理内存的？_

## 内存分配策略
 1. 如果大小 <1M则 会大方的给我们一份double的内存
 2. 如果大小 >1M   如5M 则多分配1M即 5+1M。

_内存有分配就会有回收，那比如说，当需要的内存由大变小时（如:原大小64M 现在只存2KB），sds会变成4kb大小的内存呢？还是维持原有大小64M呢_

这是一个很好的问题。你不妨猜猜看？

_我想应该是会变小吧，因为这样可以节省内存空间。_

嗯，我原来也是这么想的，但其实，咱俩都猜错了。答案是维持原有大小，只是会改变free的值。这样做的好处是，如果内存又变化了，它就不用再去申请了。
    
_哦，这样啊。晓磊哥我还有最后一个问题。就是redis sds字符串最大可以存储多大的字符串？_

这个问题很有意思。我们可以下期再说。那么，这一期的上读书会就到此为止了，我们下期再见！

_下期见~_
