各位朋友大家好：
    先自我介绍一下啊，笔名:无名秀才，为什么叫无名秀才呢？
    

 - 第一、本人和万千码农一样像“无名”小卒一样，在公司里干着搬砖的活儿。
  - 第二、本人比较瘦弱，不知道是不是和长期熬夜写代码，加班有关。手不能提，肩不能抗的。古时候称这种读书人为“穷秀才”。
  - 第三、没有什么才华，首尾相连“无才”。 大家也可以称呼我为晓磊哥，同事也这么称呼(这样不显得老)。  
      今天我们来聊聊《Redis设计与实现》这本书。提到Redis相信很多码农都很熟悉。Redis是一个key-value存储系统和Memcache类似，它支持存储的value类型相对更多，包括string、list、set、zset和hash 以及订阅/发布等功能。但这本书并不是介绍怎么使用Redis的，而是对Redis的实现原理进行了介绍。力图展示其核心数据结构以及关键的算法思想，并让我们能够快速、有效的了解Redis的内部构造以及其运作机制。敲黑板划重点了，**如果只是对Redis实现原理感兴趣，但是又不想深入研究Redis源代码那么读这本书就够了。**（这是书上说的，不是我说的啊。我觉得时间充裕的还是可以看完对应章节，看下对应部分代码，毕竟Redis源码并不算多。有问题大家可以留言讨论，不喜勿喷）
      好，废话不多说，直奔主题。
      

## 第一章

是对整本书的一个整理。没有什么太多可以说的，就过了。

## 第二章

### 简单动态字符串 SDS 
```
struct sdshdr {
	int len; //buf数组中已使用字节的数量,等于SDS所保存字符串的长度
	int free; // buf数组中未使用字节的数量
	char buf[]; // 字节数组，用于保存字符串
}
```

图中示例：

 - free 的值是0，表示这个SDS分配的空间都被用完了。
 - len 的值是5， 表示这个SDS 保存了5个字节长的字符串
 - buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，而最后一个字节则保存了空字符'\0'。
（但是最后一个字节'\0'是不计入len的对SDS的使用者来说是透明的，我觉得这一点还是挺不错的。不用获得以后-1什么的。）



## 如此设计的优点：
感觉这个sds和C字符串的功能差不多都是存字符串的嘛。为毛要多此一举封装一个结构体呢。接下来讨论一下sds的有点。

 1. 获取字符串长度复杂度O(1)。
 2. API安全，杜绝缓冲区溢出：如果buf由小变大，会自动判断buf大小是否足够，如果不够重新申请内存。归一化，避免内存溢出。
 3. 减少修改字符串时带来的内存重新分配次数。避免频繁申请内存，内存拷贝，等io操作。
 4. 二进制及文本

## 内存分配策略
 1. 如果大小 <1M则直接分配1M内存。
 2. 如果大小 >1M   如5M 则多分配1M即 5+1M。

## 内存回收策略
惰性回收：刚才我们说了 buf由小变大，sds会自动判断大小，如果不足会申请内存，那么如果由大变小呢（如:原大小64M 现在只存2个字节了），sds会变成1M大小的内存呢？还是维持原有大小64M呢？ 答案是维持原有大小，只是会改变free的值。
    
    

    
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExOTg0MDU3OTYsLTU3NTIxNDg0Nl19
-->